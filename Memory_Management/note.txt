大纲
1. 内存类型概述
    内存地址和十六进制数
        easy

    使用调试器分析内存
        gdb 
            退出命令为q
            调试命令
                进入目录之后
                g++ -g main.cpp
                gdb ./a
            gdb命令
                list 展示c++代码
                    (gdb) list
                    1       #include <stdio.h>
                    2
                    3       int main()
                    4       {
                    5           char str1[] = "UDACITY";
                    6           printf("%s", str1);
                    7
                    8           return 0;
                    9       }(gdb)  
                增加断点 break +lineNumber
                    (gdb) break 5
                    断点的内存地址：Breakpoint 1 at 0x40141e: file .\1_memory_location.cpp, line 5.
                执行程序
                    run
                    执行到断点时：
                        Breakpoint 1, main () at .\1_memory_location.cpp:5
                        5           char str1[] = "UDACITY";
                在断点执行下一步
                    step
                        (gdb) step
                        6           printf("%s", str1);
                    这时第五行已经执行，并将字符串存在了内存中
                打印变量
                    p + 变量名
                        (gdb) p str1
                        $1 = "UDACITY"

                    p + & + 变量名  
                        获得变量的内存地址
                        (gdb) p &str1
                        $2 = (char (*)[8]) 0x61ff18

    计算机内存的类型
        cpu->cache->RAM(Physical RAM,Virtual Memory)->Permanent Storage Areas

        计算机的使用过程
            1.打开计算机后，pc会从其只读存储器 （read-only memory ROM） 加载数据并执行开机自检 （power-on self-test POST），
                以确保所有主要组件正常工作。此外，计算机内存控制器通过简单的读/写操作检查所有内存地址，以确保内存正常工作    
            2.执行自检后，计算机从ROM加载基本输入/输出系统（basic input/output system BIOS）。
                BIOS的主要任务是通过提供有关存储设备，启动顺序，安全性或自动设备识别功能等基本信息来使计算机正常运行。
            3.在简单系统上激活更复杂系统的过程称为“自举(bootstrapping)”：
                它是使用软件自行启动软件驱动系统的先有鸡还是先有蛋的问题的解决方案。
                在引导期间，计算机将操作系统 （OS） 从硬盘驱动器加载到随机存取内存 （random access memory  RAM） 中。
                RAM被认为是“随机访问”，因为任何存储单元都可以通过在矩阵状内存布局中与相应的行和列相交来直接访问。
                出于性能原因，只要计算机打开电源，操作系统的许多部分就会保留在RAM中。
            4.当应用程序启动时，它将加载到 RAM 中。
                但是，多个应用程序组件仅按需加载到 RAM 中以保留内存。在运行时打开的文件也会加载到 RAM 中。
                保存文件时，该文件将写入指定的存储设备。关闭应用程序后，它将从 RAM 中删除。

        这个简单的使用场景显示了RAM的核心重要性。每次加载数据或打开文件时，都会将其放入此临时存储区域 

        cache
            为了最大限度地提高 CPU 性能，快速访问大量数据至关重要。如果 CPU 无法获取所需的数据，它将停止并等待数据。
            因此，在设计新的存储芯片时，工程师必须适应可用CPU的速度。他们面临的问题是，能够跟上以几GHz运行的现代CPU的内存非常昂贵。
            解决方案是少量使用昂贵的内存，然后使用大量较便宜的内存进行备份。

            CPU 的位大小（ bit size）决定了它可以同时访问 RAM 内存中多少字节的数据。
                16 位 CPU 可以访问 2 个字节（每个字节由 8 位组成），而 64 位 CPU 一次可以访问 8 个字节。
            CPU的处理速度以千兆赫兹或兆赫兹为单位，表示它在一秒钟内可以执行的操作数。

    缓存
        利用cpu访问cache的时空特性，可以编写更高效的c++程序

        单核CPU芯片通过多条总线与外界相连。(图\Memory_Management\01_Overview_of_Memory_Type\02_Cache_friendly_coding\c14-fig1)
            有一个缓存总线，它导致一个名为L2的缓存（ L2 cache），
            并且有一个系统总线以及一个内存总线，它通向计算机主内存。
            后者拥有相对较大的RAM，而L2缓存以及L1缓存非常小，L1缓存也是CPU本身的一部分。
        
        多核cpu的架构如下（图\Memory_Management\01_Overview_of_Memory_Type\02_Cache_friendly_coding\c14-fig2）
            1.Level 1 cache
                层次结构中速度最快、最小的内存类型。在大多数系统中，L1 高速缓存不是很大。
                大多数情况下，它在16到64 kBytes的范围内，其中指令和数据的内存区域彼此分开
                （L1i和L1d，其中“i”代表“指令”，“d”代表“数据”）。
                L1 高速缓存的重要性随着 CPU 速度的提高而增长。在 L1 高速缓存中存放最常需要的指令和数据，
                因此需要尽可能少地访问慢速主存储器。Level 1 cache可避免数据传输延迟，并有助于优化 CPU 的利用。
            2.Level 2 cache
                位于 CPU 附近，并且与 CPU 有直接连接。L2 高速缓存和 CPU 之间的信息交换由计算机主板上的 L2 控制器管理。
                L2 高速缓存的大小通常等于或小于 2 MB。在现代多核处理器上，L2 高速缓存通常位于 CPU 本身内。
                在时钟速度更高或L2高速缓存更大的处理器之间进行选择可以按如下方式：
                    时钟速度越高，单个程序运行得更快，尤其是那些计算要求较高的程序。
                    一旦几个程序同时运行，更大的缓存是有利的。
                    通常，具有具有大缓存的处理器的普通台式计算机比具有高时钟速率的处理器的正常台式计算机更好。
            3.Level 3 cache
                在多核处理器的所有内核之间共享。使用 L3 高速缓存，多核处理器的高速缓存一致性协议可以更快地工作。
                该协议比较所有内核的缓存以保持数据一致性，以便所有处理器可以同时访问相同的数据。
                因此，L3 高速缓存的功能较少，但旨在简化和加速高速缓存一致性协议和内核之间的数据交换。

        理想情况下，CPU 所需的数据应从各种缓存中读取，用于所有内存访问操作的 90% 以上。这样，RAM和硬盘的高延迟就可以得到有效的补偿。

        时空位置（Temporal and Spatial Locality）
            不同内存类型之间的数量级值得注意。虽然L1访问操作接近光子以光速行进1英尺的速度，
            但L2访问的延迟已经慢了大约一个数量级，而对主存储器的访问则慢了两个数量级。

        算法设计
            两个原则来提高运行时性能：
                1.时间局部性（Temporal locality）意味着访问的地址范围可能会在不久的将来再次使用。
                随着时间的推移，相对频繁地访问相同的内存地址（例如，在循环中）。此属性可在内存层次结构的所有级别使用，以保持内存区域可尽快访问。
                2.空间局部性（Spatial locality ）意味着在访问地址范围之后，下一次访问附近的地址的可能性很高（例如，在数组中）。
                随着时间的推移，彼此非常接近的内存地址会再次被多次访问。通过在内存访问期间将相邻地址区域向上移动到下一个层次结构级别，可以利用此漏洞

    虚拟内存
        内存耗尽会发哦之计算机变慢
        虚拟内存的基本思想是将程序可能使用的地址与物理计算机内存中的地址分开。
        通过使用映射函数，对（虚拟）内存的访问可以重定向到保证免受其他程序保护的真实地址。

        可寻址内存的总量是有限的，并且取决于系统的体系结构（例如32位-》4GB内存地址）

        在MIPS（"Microprocessor without interlocked pipeline stages"没有互锁流水线级的微处理器）等典型架构上，
        每个程序都承诺可以访问从0x00000000到0xFFFFFFFF的地址空间。
        但是，如果可用物理内存的大小仅为 1GB，则一旦超过 30 位 RAM 地址空间，1 对 1 映射将导致未定义的行为。
        但是，对于虚拟内存，将在程序看到的虚拟地址空间与各种存储设备（如RAM和硬盘）的物理地址之间执行映射。
        通过映射，操作系统可以将物理内存用于当前正在使用的进程部分，并将虚拟内存的其余部分备份到辅助存储位置（如硬盘）。
        使用虚拟内存，RAM的大小不再是限制，因为系统硬盘也可用于存储信息。

        对于虚拟内存，RAM 充当驻留在辅助存储设备上的虚拟内存空间的缓存。在 Windows 系统上，该文件就是这样一个大小不一的虚拟内存容器。
        为了加快系统速度，有必要以将此文件存储在SSD而不是慢速磁性硬盘驱动器上的方式调整系统设置，从而减少延迟。

        简而言之，虚拟内存保证了固定大小的地址空间，该空间在很大程度上与系统配置无关。此外，操作系统保证不同程序的虚拟地址空间不会相互干扰。

        术语(Memory_Management\01_Overview_of_Memory_Type\c15-fig3)
            1.内存页（memory page）是由计算机体系结构和操作系统定义的虚拟内存中许多直接连续的内存位置。
            计算机内存被划分为大小相等的内存页。内存页的使用使操作系统能够执行虚拟内存管理。
            整个工作内存被划分为多个块（tiles），
            该计算机体系结构中的每个地址都被内存管理单元（Memory Management Unit MMU）解释为逻辑地址并转换为物理地址。
            2.内存帧（memory frame）与内存页的概念基本相同，主要区别在于它位于物理主内存而不是虚拟内存中。

        内存运行两个进程时
            两个进程都有自己的虚拟内存空间。某些页面映射到物理内存中的帧，而某些页面则不是。
            如果进程 1 需要使用从地址 0x1000 开始的内存页中的内存，则当所需数据不存在时，将发生页错误。
            然后，内存页将映射到物理内存中的空闲内存帧。
            【请注意，虚拟内存地址与物理地址不同】。
            进程 1 的第一个内存页从虚拟地址0x0000开始，映射到从物理地址0x2000开始的内存帧。
            
2. 变量和内存（stack）
    进程内存模型
        操作系统为每个程序分配了自己的虚拟内存。此地址空间以线性方式排列，每个地址存储一个数据块。它还分为几个不同的区域

        自顶向下
            1.堆栈（stack）是具有固定最大大小的连续内存块。如果程序超过此大小，它将崩溃。
            堆栈用于存储自动分配的变量，如局部变量或函数参数。如果程序中有多个线程，则每个线程都有自己的堆栈内存。
            当执行路径进入作用域时，将分配堆栈上的新内存，并在作用域离开后再次释放。
            重要的是要知道堆栈由编译器“自动”管理，这意味着我们不必担心分配和解除分配。
            2.堆（heap 在C++中也称为“free store”）是具有动态存储的数据所在的位置。
            它在程序中的多个线程之间共享，这意味着堆的内存管理需要考虑并发性。这使得堆中的内存分配比堆栈分配更复杂。
            通常，对于操作系统来说，管理堆上的内存（计算上）更昂贵，这使得它比堆栈内存慢。
            与堆栈相反，堆不是由系统自动管理的，而是由程序员自动管理的。
            如果在堆上分配了内存，则程序员有责任在不再需要它时再次释放它。如果程序员管理堆很差或根本没有，就会有麻烦。
            3.BSS (Block Started by Symbol)在许多编译器和链接器中用于包含用零值初始化的全局和静态变量的段。
            例如，此内存区域适用于未使用预定义值初始化的数组。
            4.数据段（Data segment）与BSS段具有相同的用途，主要区别在于数据段中的变量已初始化为零以外的值。
            数据段（和BSS）中变量的内存在程序运行时分配一次，并在其整个生命周期中保留。

        C++中的内存分配
            1.静态内存分配对存储在 BSS 和 Data 段中的静态和全局变量执行。这些类型的变量的内存在程序运行时分配一次，并在程序的整个生命周期中持续存在。
            2.对存储在堆栈上的函数参数和局部变量执行自动内存分配。这些类型的变量的内存在执行路径进入作用域时分配，并在作用域离开后再次释放。
            3.动态内存分配是程序在需要时在运行时从操作系统请求内存的可能性。这是自动分配和静态分配的主要区别，在自动和静态分配中，变量的大小必须在编译时已知。
            动态内存分配不是在有限的栈上执行的，而是在堆上执行的，因此（几乎）仅受地址空间大小的限制。

    stack的自动内存分配
        每次调用函数时，堆栈都会增长（从上到下），每次函数返回时，堆栈都会收缩。
        当使用多个线程（如在并发编程中）时，重要的是要知道每个线程都有自己的堆栈内存 - 这可以被认为是线程安全的

        stack的特点
            1.堆栈是连续的内存块。它不会变得碎片化（与堆相反），并且具有固定的最大大小
            2.当超过堆栈内存的最大大小时，程序将崩溃
            3.在堆栈上分配和释放内存的速度很快。它仅涉及将堆栈指针移动到新位置

    按值调用与按引用调用
        void AddThree(int *val)
        void AddFour(int &val)
            都是传入地址
               void AddFour(int &val)在call的时候可以像值传递一样 AddFour(val);
               void AddThree(int *val)在call的时候需要传入地址（*内存放的类型）AddThree(&val);

3.动态内存分配（堆）
    堆内存
        堆内存，也称为 动态内存 ，是程序（和程序员）可用于存储数据的重要资源。

        堆内存向上增长，而堆栈则向相反方向增长。我们在上一课中看到，自动堆栈内存会随着每个函数调用和局部变量而缩小和增长。
            一旦变量的作用域离开，栈就会自动解除分配，堆栈指针也会相应地向上移动。
        堆内存在许多方面是不同的：程序员可以通过发出诸如或之类的命令来请求分配内存。
            此内存块将保持分配状态，直到程序员显式发出命令。
            堆内存的巨大优势是程序员可以施加的高度控制，尽管代价是更大的责任，因为堆上的内存必须得到主动管理。
            malloc new free delete
        
        heap的属性
            1.与栈上的局部变量相反，内存现在可以在任意作用域中分配（例如，在函数内部），而不会在作用域离开时将其删除。
            因此，只要函数返回分配的内存块的地址，调用方就可以自由地使用它。
            2.栈上的局部变量在编译时分配。因此，例如字符串变量的大小可能不合适。因为在程序执行并且用户输入它之前，字符串的长度将未知。
            对于局部变量，解决方案是分配足够长的数组，并希望实际长度不超过缓冲区大小。
            使用动态分配的堆内存，变量在运行时分配。这意味着上述字符串变量的大小可以根据用户输入的实际长度进行定制。
            3.堆内存仅受地址空间大小和可用内存的约束。借助现代64位操作系统和大型RAM内存和硬盘，程序员可以控制大量内存。
            但是，如果程序员忘记解除分配堆内存块，则在程序终止之前，它将保持未使用状态。这称为“内存泄漏”。
            4.与栈不同，堆在多个线程之间共享，这意味着堆的内存管理需要考虑并发性，因为多个线程可能会争用相同的内存资源。
            5.在堆栈上分配或释放内存时，栈指针只是向上或向下移动。
            由于栈内存管理的顺序结构，栈内存可以轻松安全地（由操作系统）管理。
            使用堆内存，分配和解除分配可以任意发生，具体取决于变量的生存期。随着时间的推移，这可能会导致内存碎片化，管理起来更加困难和昂贵。
        
        内存碎片
            一个典型症状是，您尝试分配一个大块，但无法分配，即使您似乎有足够的可用内存
            虚拟内存的系统上，这不是一个问题，因为大型分配只需要在虚拟地址空间中连续，而不需要在物理地址空间中连续
            内存严重碎片化时，内存分配可能需要更长的时间，因为内存分配器必须执行更多工作才能为新对象找到合适的空间

    使用 malloc 和 free
        从c中继承而来
        
    使用新建和删除
    典型的内存管理问题

4.资源复制策略
    复制语义
    左值和右值
    移动语义

5. 智能指针
    资源获取是初始化 （RAII）
    智能指针
    转让所有权