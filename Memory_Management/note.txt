大纲
1. 内存类型概述
    内存地址和十六进制数
        easy

    使用调试器分析内存
        gdb 
            退出命令为q
            调试命令
                进入目录之后
                g++ -g main.cpp
                gdb ./a
            gdb命令
                list 展示c++代码
                    (gdb) list
                    1       #include <stdio.h>
                    2
                    3       int main()
                    4       {
                    5           char str1[] = "UDACITY";
                    6           printf("%s", str1);
                    7
                    8           return 0;
                    9       }(gdb)  
                增加断点 break +lineNumber
                    (gdb) break 5
                    断点的内存地址：Breakpoint 1 at 0x40141e: file .\1_memory_location.cpp, line 5.
                执行程序
                    run
                    执行到断点时：
                        Breakpoint 1, main () at .\1_memory_location.cpp:5
                        5           char str1[] = "UDACITY";
                在断点执行下一步
                    step
                        (gdb) step
                        6           printf("%s", str1);
                    这时第五行已经执行，并将字符串存在了内存中
                打印变量
                    p + 变量名
                        (gdb) p str1
                        $1 = "UDACITY"

                    p + & + 变量名  
                        获得变量的内存地址
                        (gdb) p &str1
                        $2 = (char (*)[8]) 0x61ff18

    计算机内存的类型
        cpu->cache->RAM(Physical RAM,Virtual Memory)->Permanent Storage Areas

        计算机的使用过程
            1.打开计算机后，pc会从其只读存储器 （read-only memory ROM） 加载数据并执行开机自检 （power-on self-test POST），
                以确保所有主要组件正常工作。此外，计算机内存控制器通过简单的读/写操作检查所有内存地址，以确保内存正常工作    
            2.执行自检后，计算机从ROM加载基本输入/输出系统（basic input/output system BIOS）。
                BIOS的主要任务是通过提供有关存储设备，启动顺序，安全性或自动设备识别功能等基本信息来使计算机正常运行。
            3.在简单系统上激活更复杂系统的过程称为“自举(bootstrapping)”：
                它是使用软件自行启动软件驱动系统的先有鸡还是先有蛋的问题的解决方案。
                在引导期间，计算机将操作系统 （OS） 从硬盘驱动器加载到随机存取内存 （random access memory  RAM） 中。
                RAM被认为是“随机访问”，因为任何存储单元都可以通过在矩阵状内存布局中与相应的行和列相交来直接访问。
                出于性能原因，只要计算机打开电源，操作系统的许多部分就会保留在RAM中。
            4.当应用程序启动时，它将加载到 RAM 中。
                但是，多个应用程序组件仅按需加载到 RAM 中以保留内存。在运行时打开的文件也会加载到 RAM 中。
                保存文件时，该文件将写入指定的存储设备。关闭应用程序后，它将从 RAM 中删除。

        这个简单的使用场景显示了RAM的核心重要性。每次加载数据或打开文件时，都会将其放入此临时存储区域 

        cache
            为了最大限度地提高 CPU 性能，快速访问大量数据至关重要。如果 CPU 无法获取所需的数据，它将停止并等待数据。
            因此，在设计新的存储芯片时，工程师必须适应可用CPU的速度。他们面临的问题是，能够跟上以几GHz运行的现代CPU的内存非常昂贵。
            解决方案是少量使用昂贵的内存，然后使用大量较便宜的内存进行备份。

            CPU 的位大小（ bit size）决定了它可以同时访问 RAM 内存中多少字节的数据。
                16 位 CPU 可以访问 2 个字节（每个字节由 8 位组成），而 64 位 CPU 一次可以访问 8 个字节。
            CPU的处理速度以千兆赫兹或兆赫兹为单位，表示它在一秒钟内可以执行的操作数。

    缓存
        利用cpu访问cache的时空特性，可以编写更高效的c++程序

        单核CPU芯片通过多条总线与外界相连。(图\Memory_Management\01_Overview_of_Memory_Type\02_Cache_friendly_coding\c14-fig1)
            有一个缓存总线，它导致一个名为L2的缓存（ L2 cache），
            并且有一个系统总线以及一个内存总线，它通向计算机主内存。
            后者拥有相对较大的RAM，而L2缓存以及L1缓存非常小，L1缓存也是CPU本身的一部分。
        
        多核cpu的架构如下（图\Memory_Management\01_Overview_of_Memory_Type\02_Cache_friendly_coding\c14-fig2）
            1.Level 1 cache
                层次结构中速度最快、最小的内存类型。在大多数系统中，L1 高速缓存不是很大。
                大多数情况下，它在16到64 kBytes的范围内，其中指令和数据的内存区域彼此分开
                （L1i和L1d，其中“i”代表“指令”，“d”代表“数据”）。
                L1 高速缓存的重要性随着 CPU 速度的提高而增长。在 L1 高速缓存中存放最常需要的指令和数据，
                因此需要尽可能少地访问慢速主存储器。Level 1 cache可避免数据传输延迟，并有助于优化 CPU 的利用。
            2.Level 2 cache
                位于 CPU 附近，并且与 CPU 有直接连接。L2 高速缓存和 CPU 之间的信息交换由计算机主板上的 L2 控制器管理。
                L2 高速缓存的大小通常等于或小于 2 MB。在现代多核处理器上，L2 高速缓存通常位于 CPU 本身内。
                在时钟速度更高或L2高速缓存更大的处理器之间进行选择可以按如下方式：
                    时钟速度越高，单个程序运行得更快，尤其是那些计算要求较高的程序。
                    一旦几个程序同时运行，更大的缓存是有利的。
                    通常，具有具有大缓存的处理器的普通台式计算机比具有高时钟速率的处理器的正常台式计算机更好。
            3.Level 3 cache
                在多核处理器的所有内核之间共享。使用 L3 高速缓存，多核处理器的高速缓存一致性协议可以更快地工作。
                该协议比较所有内核的缓存以保持数据一致性，以便所有处理器可以同时访问相同的数据。
                因此，L3 高速缓存的功能较少，但旨在简化和加速高速缓存一致性协议和内核之间的数据交换。

        理想情况下，CPU 所需的数据应从各种缓存中读取，用于所有内存访问操作的 90% 以上。这样，RAM和硬盘的高延迟就可以得到有效的补偿。

        时空位置（Temporal and Spatial Locality）
            不同内存类型之间的数量级值得注意。虽然L1访问操作接近光子以光速行进1英尺的速度，
            但L2访问的延迟已经慢了大约一个数量级，而对主存储器的访问则慢了两个数量级。

        算法设计
            两个原则来提高运行时性能：
                1.时间局部性（Temporal locality）意味着访问的地址范围可能会在不久的将来再次使用。
                随着时间的推移，相对频繁地访问相同的内存地址（例如，在循环中）。此属性可在内存层次结构的所有级别使用，以保持内存区域可尽快访问。
                2.空间局部性（Spatial locality ）意味着在访问地址范围之后，下一次访问附近的地址的可能性很高（例如，在数组中）。
                随着时间的推移，彼此非常接近的内存地址会再次被多次访问。通过在内存访问期间将相邻地址区域向上移动到下一个层次结构级别，可以利用此漏洞

    虚拟内存
        内存耗尽会发哦之计算机变慢
        虚拟内存的基本思想是将程序可能使用的地址与物理计算机内存中的地址分开。
        通过使用映射函数，对（虚拟）内存的访问可以重定向到保证免受其他程序保护的真实地址。

        可寻址内存的总量是有限的，并且取决于系统的体系结构（例如32位-》4GB内存地址）

        在MIPS（"Microprocessor without interlocked pipeline stages"没有互锁流水线级的微处理器）等典型架构上，
        每个程序都承诺可以访问从0x00000000到0xFFFFFFFF的地址空间。
        但是，如果可用物理内存的大小仅为 1GB，则一旦超过 30 位 RAM 地址空间，1 对 1 映射将导致未定义的行为。
        但是，对于虚拟内存，将在程序看到的虚拟地址空间与各种存储设备（如RAM和硬盘）的物理地址之间执行映射。
        通过映射，操作系统可以将物理内存用于当前正在使用的进程部分，并将虚拟内存的其余部分备份到辅助存储位置（如硬盘）。
        使用虚拟内存，RAM的大小不再是限制，因为系统硬盘也可用于存储信息。

        对于虚拟内存，RAM 充当驻留在辅助存储设备上的虚拟内存空间的缓存。在 Windows 系统上，该文件就是这样一个大小不一的虚拟内存容器。
        为了加快系统速度，有必要以将此文件存储在SSD而不是慢速磁性硬盘驱动器上的方式调整系统设置，从而减少延迟。

        简而言之，虚拟内存保证了固定大小的地址空间，该空间在很大程度上与系统配置无关。此外，操作系统保证不同程序的虚拟地址空间不会相互干扰。

        术语(Memory_Management\01_Overview_of_Memory_Type\c15-fig3)
            1.内存页（memory page）是由计算机体系结构和操作系统定义的虚拟内存中许多直接连续的内存位置。
            计算机内存被划分为大小相等的内存页。内存页的使用使操作系统能够执行虚拟内存管理。
            整个工作内存被划分为多个块（tiles），
            该计算机体系结构中的每个地址都被内存管理单元（Memory Management Unit MMU）解释为逻辑地址并转换为物理地址。
            2.内存帧（memory frame）与内存页的概念基本相同，主要区别在于它位于物理主内存而不是虚拟内存中。

        内存运行两个进程时
            两个进程都有自己的虚拟内存空间。某些页面映射到物理内存中的帧，而某些页面则不是。
            如果进程 1 需要使用从地址 0x1000 开始的内存页中的内存，则当所需数据不存在时，将发生页错误。
            然后，内存页将映射到物理内存中的空闲内存帧。
            【请注意，虚拟内存地址与物理地址不同】。
            进程 1 的第一个内存页从虚拟地址0x0000开始，映射到从物理地址0x2000开始的内存帧。
            
2. 变量和内存
    进程内存模型
    自动内存分配（堆栈）
    按值调用与按引用调用

3.动态内存分配（堆）
    堆内存
    使用 malloc 和 free
    使用新建和删除
    典型的内存管理问题

4.资源复制策略
    复制语义
    左值和右值
    移动语义

5. 智能指针
    资源获取是初始化 （RAII）
    智能指针
    转让所有权