多线程
    错现场程序的执行成为并发

    进程与线程
        进程（也成为task）
            是运行时的计算机程序。它由操作系统（OS）提供的运行时环境以及程序在执行期间的嵌入式二进制代码组成。
            进程由操作系统通过某些操作进行控制

            进程的几种状态（c2-2-a2b.png）
                就绪 ：创建后，进程进入就绪状态并加载到主内存中。该进程现在已准备好运行，并正在等待 CPU 时间片执行。
                    准备由 CPU 执行的进程存储在由操作系统管理的队列中。
                正在运行 ：操作系统已选择要执行的进程，并且进程中的指令在一个或多个可用的 CPU 内核上执行
                已阻止（blocked） ：被阻止的进程是等待事件（如系统资源变为可用）或 I/O 操作完成的进程。
                已终止 ：当进程完成其执行或被显式终止时，它将更改为“已终止”状态。
                    程序不再执行，但该进程仍作为“僵尸进程”保留在进程表中。当它最终从进程表中删除时，其生存期结束。
                就绪挂起（Ready Suspended） ：最初处于就绪状态但已从主内存中换出并放入外部存储的进程称为挂起就绪状态。
                    每当再次移动到主内存时，该进程将转换回就绪状态。
                已阻止挂起（blocked suspended） ：被阻止的进程也可能从主内存中换出。它可以在与“就绪挂起”进程相同的条件下再次换回。
                    在这种情况下，进程将移动到阻止状态，并且可能仍在等待资源变为可用。
            
            进程由操作系统的调度程序管理。调度程序可以让进程运行直到它结束或blocked（非中断调度程序），
                也可以确保当前运行的进程在短时间内中断。
                调度程序可以在不同的活动进程（中断调度程序）之间来回切换，交替地为它们分配 CPU 时间片。
        
        由于进程的管理在计算上很繁重，因此操作系统支持一种更资源友好的实现并发操作的方式：线程。

        线程
            线程表示进程中的并发执行单元。与上述的进程相比，线程的特征是轻量级进程（ light-weight processes LWP）。
                线程都更容易创建和销毁：在许多系统中，线程的创建速度比创建进程快100倍。这在并发操作需求动态变化的情况下尤其有利。

            状态
                新建（new）：线程在创建后处于此状态。在它实际运行之前，它不会占用任何 CPU 资源。
                可运行(Runnable ) ：在此状态下，线程可能实际上正在运行，或者它可能已准备好在任何时刻运行。
                    线程调度程序负责为线程分配 CPU 时间片。
                已阻止（blocked） ：线程在等待 I/O 操作完成时可能处于此状态。
                    当被阻止时，线程无法继续执行，直到它再次移动到可运行状态。
                    在此状态下，它不会消耗任何 CPU 时间。线程调度程序负责重新激活线程
        
        一个进程可以包含多个线程，或者如果程序流中未提供并行处理，则只能包含单个线程。

        区别
            每个进程都有自己的地址空间，而线程不需要创建新的地址空间。进程中的所有线程都可以访问其共享内存。
                线程还共享其他依赖于操作系统的资源，如处理器、文件和网络连接。
                因此，线程的管理开销通常小于进程的管理开销。
                但是，线程之间没有相互保护，在访问共享进程资源时必须仔细同步以避免冲突。
    
    编程：
        需要增加命令 
            g++ -std11  main.cpp
            否则无法识别 error: ‘std::this_thread’ has not been declared


    [切换到linux编程，windows到thread环境有点麻烦]
    linux出现的问题
        对‘pthread_create’未定义的引用
            g++ -std=c++11 main.cpp -lpthread 在cmd末尾增加-lpthread的链接库
        error: ‘std::chrono’ has not been declared
            g++ -std=c++11 main.cpp 强调以c++ 11为编译标准


    运行一个线程
        //create thread
        std::thread t(threadFunction);
        //创建线程并执行函数

        如果程序正常退出，但是未等到子线程结束main函数就结束了
            会报错
                terminate called without an active exception
                已放弃 (核心已转储)

    join()函数是一个等待线程完成函数，主线程需要等待子线程运行结束了才可以结束
    称为分离线程函数，使用detach()函数会让线程在后台运行，即说明主线程不会等待子线程运行结束才结束
    detach()函数是子线程的分离函数，当调用该函数后，线程就被分离到后台运行，主线程不需要等待该线程结束才结束
        detach()进入后台运行并不是被kill了
    
function object（函数对象）
    在上部分中，已经实现了创建线程，并向其传递一个需要执行的函数。这个部分希望传递一个函数对象实例，这实际是一个object

    传递数据，并启动线程使用非常小代码空间到为一个名为lambda函数